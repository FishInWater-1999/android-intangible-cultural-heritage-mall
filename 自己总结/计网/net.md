#### OSI 七层模型⭐️⭐️

- osi（Open System Interconnection 开发系统互联通信） 每一层都是一个协议包，就是说包含了很多协议，然后一层调用一层地按照协议封装数据，再传输给下一层

1. 应用层：是为我们的网络应用程序（比如浏览器 ）提供服务的，要注意的是它提供的是协议，而不是接口，比如我们浏览器用的是 http/https 协议，邮件用的是 SMTP 协议，文件用的是 FTP/TFTP 协议这种，终端用的是 Telnet 协议，所以它的本质是一个由几十种协议构成的协议包。
2. 表示层：应用层传输来的数据有字母和数字组成，表示层从应用层接收到这些数据后，将他们 ‘ 翻译 ’ 为机器可以理解的二进制文件。然后再通过‘ 数据压缩 ’ ，特别是对视频数据进行压缩，来减少了原先数据的比特数，来保证更快的传输；最后通过 SSL （CA 相当于密钥，CA 用私钥将数据加密后变为 SSL 证书）对数据进行了加解密，保证了他的安全性
3. 会话层：是整个会话的管理者，包括身份验证、授权的过程都是在会话层；比如说从服务器下载图片这个过程，服务器首先要验证你是不是他的用户（ 有没有账户和密码 ），然后看看你有没有下载这张图片的权限，有的话会把图片划分为一个个数据包（ 包括内容、格式 ）进行发送。（ 等到客户端的会话层接收后，会把他们整理，再发给浏览器去显示 ）
4. 传输层：会把我们会话层的数据包加工为多段，也就是多个包含源端口号、目的端口号和序列号的小数据单元进行发送，以方便正确的浏览器接收到正确的数据，并按顺序进行重组；同时在流量控制中，服务端发送数据是 100mbps，而客户端只能以 10mbps 接收，那么服务端传输层就会把数据量降低到和客户端一样的 10mbps，以此来避免数据的丢失和进行重传。也就是通过分段、流量控制、差错控制来保证通信过程中的可靠性。我们的 TCP 和 UDP 协议都是在这一层进行着面向连接和无连接的传输
5. 网络层：收到传输层发来的数据段后，网络层负责将其从一台计算机传输到另一台计算机中，其中的传输的每个单元称为一个数据包。它的功能是为每个数据包分配发送方和接收方的 IP 地址，来确保数据包正确到达；再根据刚分配的 IPv4 或者 Ipv6 地址，为其分配子网掩码（子网掩码用来码 IP 地址标记为 ‘ 网络地址 ’ 和 ‘ 主机地址 ’ ）后确定传递数据的最佳路径，最后通过路由将数据包发送到目的地址，整个过程也就是也就是逻辑寻址（也就是 IP 寻址）、路由和路劲确定
6. 数据链路层：负责将 Mac 地址（是由计算机厂家设定的号码）或发送者和接收者添加到数据包里封装成一个数据帧，链路层是传输的管理者，它控制帧在物理介质上的传输过程，比如控制、接收和差错检验。在实际应用中，由于不同电脑连接的网络不同（比如每个人家里的电脑都连的不同网络），它们之间会使用网络层的 IP 协议来进行通信，而网络层以及更高级别的层就是在链路层的帮助下进行通讯的。总结得来说就是链路层为 OSI 更高层的应用，提供了对媒体的访问。将网络层传来的，已经经过逻辑寻址的数据包，进行物理寻址，其过程是。但如果链路层上有多个媒体在发数据，消息就可能发生冲突，变成一个无法理解的无用信息，因此链路层会关注什么时候没提示空闲的再发送消息，这就是所谓的 CSMA （载波监听多路访问）

7. 物理层：划分到物理层时，数据已经是二进制的数据包，物理层就负责将这些二进制序列转化为信号（不一定是电信号，比如 wifi、光纤），从而在媒体上传播

- 最后，数据在接收方被反向解封，然后显示在用户的屏幕上

   

#### tcp三次握手、四次挥手⭐️

- 三次握手：⭐️

	- 第一次握手：客户端发送SYN=1，ACK=0，seq=x的请求连接报文，客户端进入SYN-SEND状态；服务器端接收后，内核为这个连接维持一个半连接状态，并将半连接状态相关的数据放在一个未连接队列中。

	- 第二次握手：通过第一次握手建立的未连接状态发送SYN=1，ACK=1，ack=x+1，seq=y的确认受到并请求连接报文，之后服务器端进入到SYN-RCVD状态；

	- 第三次握手：客户端接收到第二次握手的报文后，发送第三次握手的ACK=1，seq=y+1，ack=x+1的确认连接报文，服务器接收到第三次握手报文后，将关于本次连接的处于未连接状态的数据从未连接队列中，转移到已连接队列。

	- 最终分配套接字：三次握手后并没有直接分配套接字，而是将连接信息存储在已连接队列中，需要调用accept来从已连接队列的队列首取出节点，并为之分配地址和套接字，然后才开始发送数据，服务器接收到第三次握手报文后立刻进入到连接状态。

 

- 四次挥手：⭐️

	- 第一次挥手：客户端与服务器端处于连接状态，客户端发送FIN=1，ACK=1， seq = u，的断开连接请求报文，客户端进入到FIN-WAIT1状态；

	- 第二次挥手：服务器接收后，立即发送ACK=1, ack=u+1, seq=v的确认收到的报文，并断开客户端发送信息，服务器接收信息的那一条连接，但保留服务器发送信息的连接，进入到CLOSE-WAIT状态；客户端接收到第二次挥手信息进入FIN-WAIT2状态，tcp连接进入半关闭状态，此时只能由服务器发送数据，客户端接收数据。

	- 第三次挥手：服务器端发送完毕，向客户端发送FIN=1，ACK=1，ack=u+1，seq=w的断开连接报文，服务器进入到LAST-ACK状态

	- 第四次挥手：客户端接收到第三次挥手信息后，法送ACK=1， ack=w+1, seq=u+1的确认报文，进入TIME-WAIT状态，时长2MSL，服务器接收到后，进入CLOSE状态

 

- TIME-WAIT状态：

	1. 为了防止服务器端没有收到第四次握手的确认报文，假如没有收到确认报文，那么会服务器的第三次挥手会超时重传，处于TIME-WAIT的客户端这时候可以发送确认报文，以关闭服务器，避免浪费资源

	2.  在经过2msl时间后，本次连接所产生的报文会全部消失，可以保证下一次连接不会收到上一次连接所产生的的报文（TIME_WAIT会占用端口内容，不释放端口（我理解的TCP连接，是两个进程的连接，这个时候进程是唯一的，端口是唯一的，但是IP地址是共享的），这样可以保证下次两个端口建立连接的时候，不会收到上一次相同连接所进行交流的任何报文。



#### tcp和udp的区别，概念以及适用范围⭐️

1. TCP是面向连接的一条双工可靠信道，UDP是一条无连接的不可靠信道。
2. TCP在传输数据时必须先建立连接，传送数据结束后，接收端应发送确认，保证信息到达，数据传输完全结束后，要释放连接；UDP在传送数据之前不需要建立连接，远地主机接收到UDP数据报后，不需要给出确认。
3. TCP不提供广播或多播服务，而UDP提供广播或多播服务
4. UDP只有一个字节的检验和作为数据检验；TCP引入了诸如确认，流量控制计时器，连接管理和拥塞管理等以确保提供可靠的，面向连接的运输服务
5. UDP发送的报文长度是应用程序给出的；TCP所发出的报文长度是根据对方给出的窗口值和当前的网络拥塞情况来决定一个报文中有多少字符
- 适用范围：
	TCP：文件传送（FTP文件传送协议），电子邮件，万维网，远程终端接入
	UDP：文件传送（TFTP简单文件传送协议），广播，路由器配置，IP地址配置，域名系统，网络管理，ip电话，流式多媒体通信和网络文件服务器等



#### TCP是怎么保证有序传输的⭐️

1. TCP为每一个字节标号，为保证数据报的可靠传递，发送方必须把已经发送的数据保留在缓冲区
2. 为每一个已经发送的数据报维护一个超时定时器
3. 如果定时器超时之前收到了对方发送的应答信息，则释放该数据报占用的缓冲区
4. 否则重传该数据报，直到应答或重传此数据超过规定的最大次数为止
5. 接收方收到数据报后，先进行CRC循环冗余校验，如果正确，则把数据交给上层协议。然后给客户端发送一个确认号x+1的累计应答包，表明截止到x号的所有数据都已经收到了



#### TCP拥塞机制、流量控制 ★

- 拥塞机制：★
	- 拥塞控制方法：慢开始、拥塞避免、快重传和快恢复
cwnd(拥塞窗口)，SMSS（发送方的最大报文段的数值），ssthresh（慢开始门限）
	- 慢开始：将cwnd设置为1，由小到大逐步增加拥塞窗口的值，拥塞窗口每次的增量为min（N，SMSS），N为原先未确认的，但现在刚刚收到的确认报文所确认的字节数，使用慢开始算法，每经过一个伦次，cwnd翻倍
	- 拥塞避免：当cwnd的值大于ssthersh之后将开始使用拥塞避免算法，使拥塞窗口缓慢的增大，每经过一个往返的时间，拥塞窗口cwnd加1，把拥塞窗口控制为按照线性规律增长，使网络不易出现拥塞
	- 超时：如果出现网络拥塞导致的超时，这时候将当前的ssthresh调整为cwnd/2，然后将cwnd设置为1，重新开始启动慢开始算法
	- 快速重传：快速重传也是超时，不同的是，它是在出现报文丢失的情况下，假设M3丢失，接收端无论接下来接收到任何信息，都要发送对M2的确认，连续收到3个M2的确认，那么将判断为M3丢失，立即进行重传。
	- 快速恢复：快速重传后，因为没有发生网络拥塞，所以不必设置cwnd为1，将cwnd与ssthresh同时设置为cwnd/2，后开始执行拥塞避免算法

- 流量控制：★
	- 基础知识：TCP在发送数据的时候，是有一个发送缓存以及接收缓存的，如果一次性发送的数据接收缓存存不下，会造成数据丢失（包括发送的数据包大小大于接收缓存，接收缓存中有未读完的信息，添加新的信息后，接收缓存装不下等情况）
	- 操作：流量控制首先是TCP的报文段中存在一个窗口字段，服务器给出的所有的确认（包括建立连接的时候作为第一条握手报文确认报文的第二次握手报文）要同过发送自己的接收窗口，客户端在接收到这个接收窗口的大小后，调整自己的发送窗口，一定不大于对方的接收窗口。（接收窗口的大小是动态变化的）
	  这个时候会出现一个问题，就是对方接收窗口为0 ，根据上述的规则，客户端就不发送数据了，这样也就没法得到对方的接收窗口大小了。所以，客户端在收到接收窗口未0的时候，要维护一个定时器，这个定时器超时的时候，要发送一个探测报文，里面有一个字节的数据，服务器在收到后，要对这个字节给出确认，确认报文中就存在了服务器的当前接收窗口的大小，如果还是0，重新定时，如果不为0，进行正常的数据传输



#### TCP粘包半粘包和拆包问题怎么处理

- 粘包问题：
	- 如果TCP数据报很短，远小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去。将会发生粘包现象
	- 接收数据端的应用层没有及时的读取缓冲区中的数据，也会发生粘包
- 拆包问题：
	- 要发送的数据大于TCP发送缓冲区剩余空间的大小，将会发生拆包
	- 要发送的数据大于MSS（最大报文长度），TCP在传输前将进行拆包

- 解决方法：
	1. 发送端给每个数据包添加包首部，首部中应至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道一个数据包的实际长度了
	2. 发送端将每个数据包封装为固定长度（不够的的可以用0来补充），这样接收端每次从接收缓冲中读取固定长度的数据就自然而然的把每个数据包拆分开来
	3. 在数据包之间添加特殊符号来设置边界，这样通过边界将不同的数据包拆分开



#### 什么是keepalive？如何使用？

- 检测tcp socket并检测连接是否在运行或者是否被破坏
- 当建立一个TCP连接时，将一系列的定时器与该连接相关联。这些定时器中某些用于处理keepalive过程。当keepalive定时器变为0时，会给对方发送一个keepalive探针包，包内没有数据，并且ACK标识打开，另一方面，会收到一个来自远方主机的回应该回应同样没有数据，并且设置ACK标识
- 阻止因为网络连接不活跃（长时间没有数据包）而导致的连接中断



#### http协议（端口号 80）
(1)HTTP是客户端与服务器端之间传输数据的一种格式规范，格式简称为“超文本传输协议”
(2)http协议与TCP/IP协议的关系
	①HTTP的长连接和短连接本质上是TCP的长连接和短连接
	②HTTP属于应用层协议，在传输层使用的是TCP协议，在网络层使用的是IP协议
(3)HTTP协议的特征
	①支持客户/服务器模式
	②简单快速
	③灵活
	④无连接
	⑤无状态
(4)如何理解http是无状态的
	①HTTP协议是无状态的指的是对事物处理没有记忆能力，服务器不知道客户端是什么状态的，也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。但是无状态不代表http不能保持tcp连接，更不代表http使用的是udp
(5)HTTP首部协议
	①通用首部字段（请求报文与响应报文都会使用的首部字段）
		1)Date：创建报文事件
		2)Connection：连接的管理
		3)Catche-Control：缓存的控制
		4)Transfer-encoding:报文主题的传输编码方式
	②请求首部字段（请求报文会使用的首部字段）
	③响应首部字段（响应报文会使用的首部字段）
	④实体首部字段（请求报文与响应报文的实体部分所使用的首部字段）
(6)HTTP状态码
	①1xx 信息提示
		1)100：告诉客户端，应该继续发送请求
	②2xx成功
		1)200：成功接收了请求，并将返回客户端所请求的结果
		2)202：成功接收了请求，但是还没有进行处理，距离会不会处理，不确定
		3)204：服务器成功处理了请求，但没有返回任何实体内容，可能返回新的头部信息
	③3xx 重定向
		1)301：客户端请求的网页已经永久的移动到新的位置
	④4xx 客户端错误
		1)404：请求失败
	⑤5xx 服务器错误
		1)500：服务器遇到未知错误
		2)503：服务器处于临时过载或维护
		(7)http报文格式
	①请求报文
		1)请求报文由请求行、请求头、空行和请求内容四个部分组成
		2)请求行：请求行中包含，请求方法字段、URL字段、协议版本字段三部分组成，之间由空格分隔开
		3)请求头：由不定数量的键值对组成，每行为一个键值对，key和value之间通过冒号分隔。作用：用于通知服务器有关客户端的请求信息
		4)空行：用来告诉服务器，接下来就是请求的内容了
		5)请求内容：涵盖请求
	②响应报文
		1)由状态行、响应头、空行和响应内容4部分构成
		2)状态行：HTTP协议版本、状态码、状态码描述三部分组成
		3)响应头：
			a.Location: 服务器返回给客户端，用于重定向到新的位置
			b.Server: 包含服务器用来建立请求的软件信息以及版本信息
			c.Vary: 标识不可缓存的请求头列表
			d.Connection: 连接方式
			e.Close: 对于请求端，告诉服务器，端开连接，不用等待后续的请求；对于服务器，表示连接已经关闭
			f.Keep-alive: 对于请求端，告诉服务器，在完成本次响应请求后，保持连接，等待本次连接的后续请求；对于响应端，表示连接保持中
	③空行：告诉请求端，接下来的内容是响应内容
	④相应内容，服务端返回给请求端的文本信息
(8)HTTP协议中的请求方式
	POST和GET和PUT区别（后文）
(9)HTTP长连接（保持长连接通过心跳检测（keepalive）机制
	①定义：客户端与服务器建立连接后不断开，然后在进行报文发送或接收。这种常用于P2P通信
(10)HTTP短连接
	①Client方与Server方每进行一次报文收发交易时才进行通讯连接。此方式常用于一对多点通信
(11)http协议实现的原理机制
![](https://user-gold-cdn.xitu.io/2020/4/2/17139bfd2c183eb8?w=692&h=227&f=png&s=124857)



#### [POST和GET的区别](https://juejin.im/post/59fc04ecf265da4317697f26)
- GET从指定的资源获取数据
- POST向指定的资源提交要被处理的数据
1. 后退/刷新：GET无害， POST数据会被重新提交
2. 书签：GET可以被收藏为书签，POST不可以
3. 缓存：GET可被缓存，POST不可缓存
4. 编码类型：GET只支持url编码，POST支持多种编码类型
5. 历史：GET的参数保留在浏览器历史中，POST不会保留
6. 对数据长度的限制：因为URL长度是有限制的，所以GET也受到限制（2048个字符），POST无限制
7. 对数据类型的限制：GET只允许ASCII字符，POST没有限制
8. 安全性：POST比GET安全性更好
9. 可见性：GET的数据在URL中，对所有人都可见，POST数据不会出现在URL中
10. 发送：GET发送一个包，POST发送两个包（先发送header，服务器响应100，再发送data)



#### [POST和PUT的区别](https://juejin.im/post/59fc04ecf265da4317697f26)

1. PUST不是幂等操作，PUT是幂等操作
2. PUST用来更新或者创建资源，PUT只是更新资源
3. 如果提交多次结果是一致的，比如修改密码，用PUT，如果提交多次，结果不一致，比如创建用户，这个时候就用POST



#### [POST,PUT和PATCH的区别](https://www.jianshu.com/p/bee85cf4e33a)

- restful 了解一下，其实就是一套规定



#### https（端口号 443）
1. http是明文传输，在需要安全的场合下不够安全。
2. https利用http进行通信，但是需要用到SSL/TLS加密数据包

- 作用：
	1）建立信息安全通道，保证数据的安全（通过加密）
	2）确认网站的真实性（通过证书）

- 利用SSL/TLS协议进行加密传输之前，客户端和服务器之间有一个握手的过程。握手的目的是为了协商出一个共同使用的密钥。
- 加密分为对称加密和非对称加密
- 对称加密：加密解密使用同一个密钥
- 非对称加密：加密有公钥和私钥两个密钥，用公钥加密，私钥才能解密，反之亦然。非对称加密比对称加密更好，但花费时间长、速度慢，只时和对少量数据进行加密。

- 握手过程是非对称加密：
	1. 客户端向服务器传送客户端SSL协议版本号，加密算法的种类，产生的随机数，以及各种其他信息
	2. 服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还向客户端发送自己的证书
	3. 利用服务器传送过来的信息验证服务器的合法性，包括：证书是否过期，发行证书的CA是否可靠，证书是否有效，证书上的域名和实际域名是否向匹配
	4. 客户端随机产生一个新的随机数，然后用公钥进行加密，归还给服务器，同时利用随机数经过运算，得到密钥
	5. 服务器利用私钥解密，得到随机数，得到与客户端相同的密钥
	6. 握手结束后，服务器与客户端通过这把密钥进行对称加密传输

#### http与https的区别
1. https需要CA的证书，一般免费的证书较少
2. http是明文传输的，https在http的基础上加入了ssl加密传输协议
3. http和https使用不同的连接方式，用的端口也不一样，http是80，https是443
4. http连接很简单，是无状态的；https协议是由SSL+http构建的可进行加密传输，身份认证的网络协议，更加安全



#### HTTP1.1和HTTP1.0的区别

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1.  **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
2. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
5. **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

> - HTTP1.0每请求一个文档就要建立TCP连接，有几次握手的时间花销，如果一个主页上有很多链接的对象需要依次进行连接，每次连接下载都要消耗这些开销。
> - HTTP1.1采用持续连接。所谓持续连接就是服务器在发送响应后仍然在一段时间内保持这条连接。使得后序的请求和响应报文都在这条连接上进行。





#### HTTP2.0 和 HTTP1.X 相比的新特性

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。





#### 基于socket网络编程和tcp/ip协议栈，讲讲从客户端send()开始，到服务端recv()结束的过程

- 客户端send()说明已经建立好了连接，并已经设置好了拥塞窗口，send()发送的数据，会先存储在tcp的发送缓存中，发送端为每个字符标号，每次取出发送窗口大小的字符按照顺序从发送窗口发送，建立tcp数据包的报头，后面添加报文数据，作为ip数据报的数据段，封装入ip数据报后，发送到路由器，路由器从路由表中查看目标服务器ip，找到记录的下一个路由器，并发送。如果ip与当前路由器相连，发送到服务器端。
服务器端接收到数据后，ip数据包检验，检验正确后将数据段也就是tcp数据包提交到运输层，tcp协议进行CRC循环冗余检验，检验无误后提交到应用层，recv()根据所指定的套接字从接收缓存中读取相应数据。



#### [TCP ip UDP 首部](https://www.jianshu.com/p/902e7d371acc)

- 看网页





----


1. get 和 post 区别，应用场景
2. Https 原理
3. http 原理
4. https 证书被篡改怎么办
5. put和post的区别，应用场景。
6. https的流程。
7. 回答过程中提到csrf，问原理
8. socket的连接过程
9. http缓存
10. 如何把ip地址存储在一个int 变量里面？
11. HTTP & HTTPS区别
12. **OSS上传凭证怎么设计缓存？怎么加密？**（**加密算法？？**）

- HTTP/HTTPS区别
- TCP了解么？握手与挥手过程？
- 长连接？
- **push怎么实现**？

- 介绍下HTTP协议
- HTTPS公钥暴露怎么办
- HTTP分段上传文件怎么保证正确
- HTTP缓存

TCP三次握手过程

HTTP/HTTPS区别？

- HTTP/HTTPs
- 状态码，100是啥意思

怎么维持的长连接 为啥要有心跳包

三次握手为什么不是两次一次 五次六次

tcp udp区别

三次握手 第二个包丢了会咋样？

http报文结构
post 和 get区别

udp怎么实现可靠传输 为什么要这么做

长连接怎么保持
为什么要有心跳包
长连接保持过程中会有什么问题

怎么保证数据传输过程的安全

https流程，客户端如何校验证书，服务器如何获得证书，证书中有什么，证书和签名又是什么，为什么不是服务器产生随机数

项目（测评，如何做的，token和session id区别，tcp报文结构、如何阅读反编译代码、如何使用tcp实现安全协议）

1. https流程
2. http如何保证包的可达
3. tcp拥塞控制、三次握手四次挥手

- http和https的区别
- 算法：判断一个字符串是否为ipv4地址

- tcp三卧四挥
- get和post的区别[没说全]
- 断点续传的实现[没答上来]
- 链表(创建，删除，添加，逆序)

https

RSA

- RSA 对称加密 非对称加密
- 本地加密使用什么
- get和post区别
- https (证书 证书链 )
- Cooke和session

Arp协议，是否听过arp攻击

- https实习加密
- tcp如何实现可靠传输
- 使用udp实现im，上层保证可靠
- http如果维护状态
- http如何实现缓存
- RSA加密的原理
- tcp三握四挥
- http 1.0 1.1 1.2变化
- udp tcp区别(可靠性即保证，面向连接)
- http https端口号(80 443) 23端口号对应的地址
- https的握手
- https的证书
- 以前用过哪些抓包工具
- 中国墙的实现(https://www.cnblogs.com/weicyNo-1/p/8125763.html)
- 你知道哪些编码集和编码方式
- utf-8，unicode的区别
- 大小端存储

三握四挥
http &hhtps
TCP
UDP
计算机分层结构
ip层路由协议
mac层的生成树协议